#! /usr/bin/ruby
# -*- coding: utf-8 -*-
#
#= 
#
#Author:: Takahiro FUJITANI (ERTL, Nagoya Univ.)
#Version:: 0.1.0
#License::
#
#== Usage:
#
#=== 
$:.unshift(File.dirname(__FILE__))
require './manager'
require 'progressbar'
require './task-CUI'

include WCBT

# 繧ｿ繧ｹ繧ｯ繧剃ｽｿ逕ｨ邇髯埼↓荳ｦ縺ｳ譖ｿ縺
def sort_tasklist_by_utilization
  @manager.tm.get_task_array.sort do |a, b|
    -1 * (a.extime/a.period <=> b.extime/b.period)
  end
end

# 謖ｮ壹＠縺溘う繝ｳ繝ャ繧ｯ繧ｹ縺ｮtasklList縺ｮ繧ｿ繧ｹ繧ｯ繧蜘orst-fit縺ｧ繝励Ο繧ｻ繝し縺ｫ蜑ｲ繧雁ｽ薙※
# @param idx 
def assign_task_worstfit(idx)
  tsk = @manager.tm.get_task_by_index(idx)
#=begin
  # long繝ｪ繧ｽ繝ｼ繧ｹ隕∵ｱゅｒ縺励※縺ｋ繧ｿ繧ｹ繧ｯ縺九メ繧ｧ繝け
  unless tsk.long_require_array.size == 0
    # long繝ｪ繧ｽ繝ｼ繧ｹ縺後≠繧句ｴ蜷茨ｼ
    # long繝ｪ繧ｽ繝ｼ繧ｹ隕∵ｱゅｒ縺吶ｋ繧ｿ繧ｹ繧ｯ縺ｮ縺ゅｋ繝励Ο繧ｻ繝し縺ｫ蜑ｲ蠖薙※繧
    ProcessorManager.proc_list.each do |p|
      p.task_list.each do |t|
        if t.long_require_array.size > 0
          #縺薙繝励Ο繧ｻ繝し縺ｫ蜑ｲ繧雁ｽ薙※
          p.assign_task(tsk)
        end
      end
    end
  else 
#=end
    proc_id = lowest_util_proc_id
    ProcessorManager.proc_list[proc_id - 1].assign_task(tsk)
  end
end


# CPU菴ｿ逕ｨ邇′荳逡ｪ菴弱＞繝励Ο繧ｻ繝しID繧定ｿ斐☆
def lowest_util_proc_id
  u = 10.0
  id = 0
  ProcessorManager.proc_list.each do |p|
    if p.util < u
      u = p.util 
      id = p.proc_id
    end
  end

  return id 
end


# 蜷繝ｭ繧ｻ繝し縺ｮ菴ｿ逕ｨ邇→蜑ｲ蠖薙※繧峨ｌ縺ｦ縺ｋ繧ｿ繧ｹ繧ｯ謨ｰ繧定｡ｨ遉ｺ
def show_proc_info
  ProcessorManager.proc_list.each do |p|
    puts "PE#{p.proc_id}(#{p.util}):#{p.task_list.size}tasks"
  end
end


#
# 繧ｹ繧ｱ繧ｸ繝･繝ｼ繝ｩ繝薙Μ繝ぅ繝√ぉ繝け(FMLP-P)
# @param[Fixnum, Fixnum] k : 繝励Ο繧ｻ繝しID景 : 蜑ｲ蠖薙※繧九ち繧ｹ繧ｯ謨ｰ
# @return [Fixnum]
#
def p_schedulability(k, i)
  tlist = ProcessorManager.get_proc(k).task_list
  return 0.0 if tlist.size == 0
  max = [i, tlist.size].min
  c = 0

  0.upto(max-1) do |j|
    t = tlist[j]
#    p t.b
    c += (t.extime + t.bw)/t.period
  end
  tsk = tlist[-1] # 譛蠕後↓霑ｽ蜉縺輔ｌ縺溘ち繧ｹ繧ｯ
  
  return ((tsk.b - tsk.bw)/tsk.period + c)
end


#
# 迴ｾ蝨ｨ蜑ｲ繧雁ｽ薙※繧峨ｌ縺ｦ縺ｋ繧ｿ繧ｹ繧ｯ繝ｪ繧ｹ繝医ｒ霑斐☆
#
def get_using_tasks
  tasks = []
  ProcessorManager.proc_list.each do |p|
    tasks += p.task_list
  end
  
  return tasks
end

#
# main
#
proc_num = 4
taskset_count = 50  # 菴ｿ逕ｨ縺吶ｋ繧ｿ繧ｹ繧ｯ繧ｻ繝ヨ謨ｰ
task_count = 20     # 繧ｿ繧ｹ繧ｯ繧ｻ繝ヨ蠖薙◆繧翫繧ｿ繧ｹ繧ｯ謨ｰ
umax = 0.3          # 繧ｿ繧ｹ繧ｯ菴ｿ逕ｨ邇譛螟ｧ蛟､
f_max = 0.1         # nesting factor
system_util_max = proc_num/2.0 # 繧ｷ繧ｹ繝Β菴ｿ逕ｨ邇譛螟ｧ蛟､
output_str = []     # 繝繧ｿ蜃ｺ蜉帷畑

# 繝励Ο繧ｰ繝ｬ繧ｹ繝舌
pbar = ProgressBar.new("繧ｹ繧ｱ繧ｸ繝･繝ｼ繝ｩ繝薙Μ繝ぅ隗｣譫, (taskset_count*(f_max/0.01).to_i+1))
pbar.format_arguments = [:percentage, :bar, :stat]
pbar.format = "%3d%% %s %s"

@manager = AllManager.new

# 繧ｹ繧ｱ繧ｸ繝･繝ｼ繝ｩ繝薙Μ繝ぅ隗｣譫舌Ν繝ｼ繝
0.0.step(f_max, 0.01) do |f|
  tasksets = 0  # 蜑ｲ蠖薙※繧九％縺ｨ縺ｮ縺ｧ縺阪◆繧ｿ繧ｹ繧ｯ繧ｻ繝ヨ謨ｰ
  taskset_count_ave = 0.0  # 蜑ｲ繧雁ｽ薙※繧峨ｌ縺溘ち繧ｹ繧ｯ繧ｻ繝ヨ縺ｮ蟷ｳ蝮
  taskset_non = 0.0        # 蜑ｲ繧雁ｽ薙※繧峨ｌ縺ｪ縺九▲縺溘ち繧ｹ繧ｯ繧ｻ繝ヨ
  taskset_count.times do |i|

    @manager.all_data_clear
    
    info =  { }
    info[:mode] = SCHE_CHECK
    info[:f] = f
    info[:umax] = umax
    info[:proc_num] = proc_num
    @manager.create_tasks(task_count, 30, 10, info)

    # 繧ｿ繧ｹ繧ｯ繝ｪ繧ｹ繝医ｒ菴ｿ逕ｨ邇髯埼〒繧ｽ繝ｼ繝
    @manager.tm.sort_tasklist_by_util
    #puts "#{@manager.tm.get_task_array.size}繧ｿ繧ｹ繧ｯ:(#{@manager.tm.get_alltask_util.round(2)})"
    #puts @manager.gm.get_group_array.size
    #puts @manager.rm.get_require_array.size

    # 繧ｿ繧ｹ繧ｯworstfit縺ｧ蜑ｲ繧雁ｽ薙※
    1.upto(@manager.tm.get_task_array.size) do |id|
      @manager.assign_task_worstfit(id-1) # 繝励Ο繧ｻ繝し縺ｫ繧ｿ繧ｹ繧ｯ蜑ｲ繧雁ｽ薙※
    end

    #add_task = @manager.tm.get_task_by_index(id-1)
    # @manager.pm.add_tasks([add_task], {:assign_mode => WORST_FIT})
    
    init_computing(@manager.tm.get_task_array)
    set_blocktime
    
    non_schedulable_flg = false # 繧ｹ繧ｱ繧ｸ繝･繝ｼ繝ｩ繝悶Ν縺ｧ縺ｪ縺九▲縺溷ｴ蜷育ｫ九※繧九ヵ繝ｩ繧ｰ
    1.upto(proc_num) do |p_id|
      #sche += p_schedulability(p_id, id+1)
      sche = p_schedulability(p_id, @manager.tm.get_task_array.size)
      #puts "\tPROC#{p_id}:#{ProcessorManager.get_proc(p_id).task_list.size}繧ｿ繧ｹ繧ｯ:#{sche.round(2)}"
      if sche < 1
        next
      else
        non_schedulable_flg = true
        break
      end
    end

    #      if sche < system_util_max
    if non_schedulable_flg == false
      # 險ｭ螳壹＠縺溘す繧ｹ繝Β菴ｿ逕ｨ邇ｒ雜∴縺ｦ縺↑縺ｴ蜷茨ｼ後ち繧ｹ繧ｯ蜑ｲ繧雁ｽ薙※縺ｧ縺阪◆縺ｨ縺吶ｋ
      taskset_count_ave += 1
    end
    pbar.inc 
  end
  @manager.save_tasks("#{JSON_FOLDER}/sche_check_#{umax}_nest")
  #puts "\t#{taskset_count_ave}"
  taskset_count_ave /= taskset_count  
  output_str << taskset_count_ave*100

end
taskset = TaskSet.new
taskset.show_taskset

filename = "#{taskset_count}taskset_umax#{umax}_edf.dat"
File.open(filename, "w") do |fp|
  f = 0.0 
  output_str.each do |str|
    fp.puts "#{f} #{str}"
    f += 0.01
  end
end
puts "#{filename}縺ｫ菫晏ｭ假ｼ
pbar.finish
#show_proc_info
#pp @proc_list
#p lowest_util_proc_id
